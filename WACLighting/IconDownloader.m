#import "IconDownloader.h"#define kAppIconHeight 48@implementation IconDownloader@synthesize appRecord;@synthesize indexPathInTableView;@synthesize delegate;@synthesize activeDownload;@synthesize imageConnection;#pragma mark- (void)dealloc{    [appRecord release];    [indexPathInTableView release];        [activeDownload release];        [imageConnection cancel];    [imageConnection release];        [super dealloc];}- (void)startDownload{    self.activeDownload = [NSMutableData data];    // alloc+init and start an NSURLConnection; release on completion/failure    NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:                             [NSURLRequest requestWithURL:                              [NSURL URLWithString:[appRecord objectForKey:@"icon"]]] delegate:self];    self.imageConnection = conn;    [conn release];}- (void)cancelDownload{    [self.imageConnection cancel];    self.imageConnection = nil;    self.activeDownload = nil;}#pragma mark -#pragma mark Download support (NSURLConnectionDelegate)- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{    [self.activeDownload appendData:data];}- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{	// Clear the activeDownload property to allow later attempts    self.activeDownload = nil;        // Release the connection now that it's finished    self.imageConnection = nil;		 [delegate appImageDidLoad:self.indexPathInTableView];}- (void)connectionDidFinishLoading:(NSURLConnection *)connection{    // Set appIcon and clear temporary data/image    UIImage *image = [[UIImage alloc] initWithData:self.activeDownload];        if (image.size.width != kAppIconHeight && image.size.height != kAppIconHeight)	{        CGSize itemSize = CGSizeMake(kAppIconHeight, kAppIconHeight);		UIGraphicsBeginImageContext(itemSize);		CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);		[image drawInRect:imageRect];		UIImage *img = UIGraphicsGetImageFromCurrentImageContext();		[appRecord setObject:img forKey:@"IconImage"];		UIGraphicsEndImageContext();    }    else    {        [appRecord setObject:image forKey:@"IconImage"];    }    	//cache the image---------------------------------------------------------------//		NSString *ImageURLString = [appRecord objectForKey:@"icon"];	//NSURL *ImageURL = [NSURL URLWithString: ImageURLString];	//generating unique name for the cached file with ImageURLString so you can retrive it back	NSMutableString *tmpStr = [NSMutableString stringWithString:ImageURLString];	[tmpStr replaceOccurrencesOfString:@"/" withString:@"-" options:1 range:NSMakeRange(0, [tmpStr length])];		NSString *filename = [NSString stringWithFormat:@"%@",tmpStr];		NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);	NSString *cacheDirectory = [paths objectAtIndex:0];	NSString *uniquePath = [cacheDirectory stringByAppendingPathComponent:filename];		if(![[NSFileManager defaultManager] fileExistsAtPath: uniquePath])	{		// The file doesn't exist, we should get a copy of it				// Fetch image				// Is it PNG or JPG/JPEG?		// Running the image representation function writes the data from the image to a file		if([ImageURLString rangeOfString: @".png" options: NSCaseInsensitiveSearch].location != NSNotFound)		{			[UIImagePNGRepresentation(image) writeToFile: uniquePath atomically: YES];		}		else if(				[ImageURLString rangeOfString: @".jpg" options: NSCaseInsensitiveSearch].location != NSNotFound ||				[ImageURLString rangeOfString: @".jpeg" options: NSCaseInsensitiveSearch].location != NSNotFound				)		{			[UIImageJPEGRepresentation(image, 100) writeToFile: uniquePath atomically: YES];		}	}		self.activeDownload = nil;    [image release];        // Release the connection now that it's finished    self.imageConnection = nil;            // call our delegate and tell it that our icon is ready for display    [delegate appImageDidLoad:self.indexPathInTableView];}@end